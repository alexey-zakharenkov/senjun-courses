# Глава 2. Объявление и использование переменных

В этой главе мы рассмотрим, как правильно объявлять и использовать переменные в Rust.

## Объявление переменных
Синтаксис объявления переменных в Rust:

```
let [mut] <variable name> [: type] [= variable value];
```

Пример:

```rust
let k = 7;
```

По умолчанию (без ключевого слова `mut`) все переменные в Rust являются **неизменяемыми**. Неизменяемость переменных — это полезная особенность языка, позволяющая писать более надежный код. Не пренебрегайте этой особенностью. Для того чтобы сделать переменную изменяемой, необходимо добавить ключевое слово `mut`.

Пример:

```rust
let mut m = 7;
m += 2;
```

Макрос `assert` проверяет истинность выражения: если выражение истинно, то программа выполняется дальше. В противном случае программа аварийно завершается с сообщением об ошибке. Код в данной задаче содержит синтаксическую ошибку, необходимо ее исправить:  {.task_text}

```rust  {.task_source #rust_chapter_0020_task_0010}
let m = 3;
m = m + 2;
println!("m = {}", m);
assert!(m == 5);
```
Переменную `m` необходимо сделать изменяемой. {.task_hint}
```rust {.task_answer}
let mut m = 3;
m = m + 2;
println!("m = {}", m);
assert!(m == 5);
```

В Rust можно не указывать тип переменной. В большинстве случаев компилятор определит тип переменной из контекста. Объявление `let n = 5` говорит компилятору, что переменная `n` имеет целочисленный тип `i32`. Но такая краткая запись не всегда возможна. Нередко требуется указывать конкретный тип переменной.

Важно учитывать, что Rust не разрешает использовать неинициализированные переменные. Это позволяет избежать целый класс ошибок, связанных с использованием неинициализированных переменных. Переменную можно объявить без инициализации, но перед первым использованием такая переменная должна быть обязательно проинициализирована.


Исправьте этот код, присвоив значение 0 переменной `counter` до первого ее использования:  {.task_text}

```rust   {.task_source #rust_chapter_0020_task_0020}
let mut counter: u32;
counter += 1;
println!("counter = {}", counter);
assert!(counter == 1);
```
Проще всего инициализировать переменную `counter` при создании. {.task_hint}
```rust {.task_answer}
let mut counter: u32 = 0;
counter += 1;
println!("counter = {}", counter);
assert!(counter == 1);
```


Обратите внимание, что язык позволяет инициализировать переменную в том месте, где она потребуется, а не сразу при объявлении:

```rust {.example_for_playground .example_for_playground_001}
let dif: i32;
let dec: i32 = 10;
let sub: i32 = 3;
dif = dec - sub;
println!("dif = {}", dif);
```


Rust выдает предупреждение для неиспользуемых переменных. Такое предупреждение возможно отключить (хоть и нежелательно), либо начать название переменной с символа подчеркивания `_`.

Исправьте этот код, чтобы избавиться от предупреждения:  {.task_text}

```rust   {.task_source #rust_chapter_0020_task_0030}
let unused = 42;
```
Необходимо добавить знак подчеркивания в начало имени переменной. {.task_hint}
```rust {.task_answer}
let _unused = 42;
```


## Область видимости и затенение переменных {#block-shadowing}
Область видимости переменной ограничена блоком, в котором эта переменная определена. Блок — это набор инструкций, заключенный между фигурными скобками `{}`. Переменная видна в блоке объявления и во всех вложенных блоках. 

В этой задаче требуется получить сумму переменных `external` и `internal`. Сейчас код некорректен, нужно его исправить. При этом переменные `external` и `sum` должны остаться во внешнем блоке, а переменная `internal` во внутреннем блоке кода:  {.task_text}

```rust {.task_source #rust_chapter_0020_task_0040}
let external = 2;
let sum;
{
    let internal = 40;
}
sum = external + internal;
println!("sum = {}", sum);
assert!(sum == 42);
```
Сумму нужно вычислять в области видимости переменной `internal`, при этом переменная `internal` должна оставаться во внутреннем блоке. {.task_hint}
```rust {.task_answer}
let external = 2;
let sum;
{
    let internal = 40;
    sum = external + internal;
}
println!("sum = {}", sum);
assert!(sum == 42);
```

В Rust есть возможность определять переменные с одинаковыми именами в одной области видимости. Это называется **затенением переменных** (shadowing). Переменная с таким же именем затеняет собой предыдущую. В примере ниже строковая переменная `count` затеняется целочисленной:

```rust {.example_for_playground .example_for_playground_002}
let count = "123";
let count: i32 = count.parse().unwrap_or(0);
println!("{}", count);
```

В примере создаются две переменные с типами `&str` и `i32`. Тип `&str` является срезом, указывающим на валидную последовательность UTF-8 символов, в данном случае на строковый литерал. Метод `parse()` преобразует строку в алгебраический тип `Result<>`, содержащий число в случае успешного преобразования либо ошибку. Метод `unwrap_or()` извлекает целочисленное значение из `Result<>` либо возвращает заданное значение в случае ошибки. О типах, включая алгебраические, будет рассказано в следующих главах.


## Заключение

- Для объявления переменных используется ключевое слово `let`.
- Без ключевого слова `mut` переменная является неизменяемой.
- Тип переменной можно опустить, если он понятен из контекста.
- Использование неинициализированной переменной недопустимо и приведет к ошибке компиляции.
- Имена неиспользуемых переменных следует начинать со знака подчеркивания `_`, чтобы избежать предупреждения от компилятора.
- Область видимости переменной ограничена блоком `{...}`, в котором она определена.
- Определение нескольких переменных с одинаковыми именами в одной области видимости называется затенением.
